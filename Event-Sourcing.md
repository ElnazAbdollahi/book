بگذارید این متن را به زبان ساده توضیح دهم:

"مری از ایده‌ای که در فصل 5 توضیح داده شده بود خوشش آمد. این ایده درباره ساختاردهی منطق کسب و کار به صورت مجموعه‌ای از Aggregate های DDD بود که رویدادهای دامنه (Domain Events) را منتشر می‌کنند. او می‌توانست تصور کند که استفاده از این رویدادها در معماری میکروسرویس بسیار مفید خواهد بود.

مری قصد داشت از این رویدادها برای پیاده‌سازی Saga های مبتنی بر Choreography استفاده کند (که در فصل 4 توضیح داده شده است). این Saga ها برای حفظ سازگاری داده‌ها بین سرویس‌های مختلف استفاده می‌شوند. همچنین او انتظار داشت از CQRS views استفاده کند (که در فصل 7 توضیح داده می‌شود) - این‌ها رپلیکاهایی هستند که امکان کوئری‌گیری کارآمد را فراهم می‌کنند."

مفاهیم کلیدی در این متن:

DDD Aggregates: مجموعه‌ای از اشیاء مرتبط که به عنوان یک واحد با هم کار می‌کنند

Domain Events: رویدادهایی که تغییرات مهم در دامنه کسب و کار را نشان می‌دهند

Choreography-based Sagas: الگویی برای مدیریت تراکنش‌های توزیع شده

CQRS views: الگویی برای جداسازی عملیات خواندن و نوشتن داده‌ها

می‌خواهید درباره هر کدام از این مفاهیم بیشتر توضیح دهم؟بگذارید این متن را به بخش‌های کلیدی تقسیم کنم و به زبان ساده توضیح دهم:

بله، حتماً. اجازه دهید با جزئیات بیشتری متن را تحلیل کنم:

۱. چالش اصلی در سیستم فعلی

در سیستم فعلی (که در فصل ۵ توضیح داده شده):

هر متد Aggregate که state را تغییر می‌دهد، یک لیست از رویدادها برمی‌گرداند

این رویدادها توسط domain service منتشر می‌شوند

اما مشکل اصلی این است که این منطق انتشار رویداد بصورت "bolt-on" (اضافه شده بعد از طراحی اصلی) به منطق کسب و کار متصل شده است

یعنی حتی اگر برنامه‌نویس فراموش کند رویدادی را منتشر کند، کد همچنان کار می‌کند

این یک ریسک جدی است چون ممکن است در جاهایی که نیاز به انتشار رویداد است، این کار انجام نشود

۲. Event Sourcing به عنوان راه حل

Event Sourcing یک رویکرد متفاوت است که:

تمام تغییرات state یک Aggregate را به صورت دنباله‌ای از رویدادها ذخیره می‌کند

تاریخچه کامل تغییرات را حفظ می‌کند

بجای اینکه انتشار رویداد یک عملیات جانبی باشد، آن را در قلب سیستم قرار می‌دهد

تضمین می‌کند هر تغییری در Aggregate حتماً با یک رویداد همراه است

به این ترتیب، مشکل "فراموش کردن انتشار رویداد" را از بین می‌برد

۳. اهمیت در معماری میکروسرویس

Event Sourcing در معماری میکروسرویس اهمیت ویژه‌ای دارد چون:

برای Saga های مبتنی بر Choreography (که در فصل ۴ توضیح داده شده) نیاز به انتشار مطمئن رویدادها داریم

برای CQRS views (که در فصل ۷ توضیح داده می‌شود) نیاز به تاریخچه کامل تغییرات داریم

در یک سیستم توزیع شده، داشتن تاریخچه دقیق تغییرات برای debugging و audit بسیار مهم است

۴. ساختار ادامه فصل

فصل قرار است این موارد را پوشش دهد:

مکانیزم دقیق کارکرد Event Sourcing

نحوه استفاده از Event Sourcing در نوشتن business logic

معرفی Event Store و نحوه ذخیره‌سازی Aggregate ها به صورت دنباله رویدادها

بررسی دقیق مزایا و معایب این رویکرد

جزئیات پیاده‌سازی Event Store

معرفی یک framework برای پیاده‌سازی business logic مبتنی بر Event Sourcing

ارتباط Event Sourcing با Saga ها و نحوه استفاده از آن به عنوان foundation برای Saga

می‌خواهید با یک مثال عملی در Node.js نشان دهم که این مشکلات چطور در دنیای واقعی اتفاق می‌افتند و Event Sourcing چطور آنها را حل می‌کند؟

نگرانی مری درباره انتشار رویدادها

مری نگران بود که منطق انتشار رویدادها (event publishing) ممکن است مستعد خطا باشد. از یک طرف، این منطق نسبتاً ساده است:

هر متد Aggregate که حالت آن را تغییر می‌دهد، لیستی از رویدادها را برمی‌گرداند

سپس سرویس دامنه این رویدادها را منتشر می‌کند

اما مشکل اینجاست که:

منطق انتشار رویدادها به منطق کسب و کار "پیچ" شده است

حتی اگر توسعه‌دهنده فراموش کند رویدادی را منتشر کند، منطق کسب و کار همچنان کار می‌کند

این می‌تواند منبع باگ‌های نرم‌افزاری باشد

راه حل: Event Sourcing

مری سال‌ها پیش با Event Sourcing آشنا شده بود - روشی برای نوشتن منطق کسب و کار و ذخیره‌سازی اشیاء دامنه که بر پایه رویدادها است. این روش مزایای زیادی دارد، از جمله:

حفظ تاریخچه کامل تغییرات یک Aggregate

تضمین انتشار رویداد هنگام ایجاد یا به‌روزرسانی Aggregate

حذف یک منبع خطای برنامه‌نویسی

ساختار فصل

این فصل شامل این موارد است:

نحوه کارکرد Event Sourcing

چگونگی استفاده از آن برای نوشتن منطق کسب و کار

نحوه ذخیره‌سازی هر Aggregate به صورت دنباله‌ای از رویدادها در Event Store

مزایا و معایب Event Sourcing

نحوه پیاده‌سازی Event Store

معرفی یک فریم‌ورک ساده برای نوشتن منطق کسب و کار مبتنی بر Event Sourcing

چگونگی استفاده از Event Sourcing به عنوان پایه‌ای برای پیاده‌سازی Saga ها

آیا می‌خواهید درباره هر کدام از این مفاهیم جزئیات بیشتری بدانید؟ می‌توانیم یک مثال ساده با Node.js بزنیم تا این مفاهیم ملموس‌تر شوند.

بله، اجازه دهید این بخش مهم را با جزئیات توضیح دهم:

توسعه منطق کسب و کار با استفاده از Event Sourcing

تعریف Event Sourcing

Event Sourcing یک رویکرد متفاوت برای:

ساختاردهی منطق کسب و کار

ذخیره‌سازی Aggregate ها

در این روش:

هر Aggregate به صورت دنباله‌ای از رویدادها ذخیره می‌شود

هر رویداد نشان‌دهنده یک تغییر وضعیت در Aggregate است

برنامه برای بازسازی وضعیت فعلی یک Aggregate، رویدادها را به ترتیب پخش می‌کند (replay events)

مزایای کلیدی

حفظ تاریخچه Aggregate ها:

برای اهداف حسابرسی (auditing)

برای اهداف قانونی و نظارتی (regulatory)

انتشار مطمئن Domain Events:

این ویژگی در معماری میکروسرویس بسیار مفید است

تضمین می‌کند هیچ رویداد مهمی از دست نمی‌رود

چالش‌ها و معایب

نیاز به یادگیری:

چون روش متفاوتی برای نوشتن منطق کسب و کار است

نیاز به تغییر دیدگاه در طراحی سیستم دارد

دشواری در Query:

کوئری زدن روی event store معمولاً دشوار است

نیاز به استفاده از الگوی CQRS دارد (که در فصل 7 توضیح داده می‌شود)

ساختار ادامه بخش

این بخش قرار است شامل:

بررسی محدودیت‌های روش‌های سنتی persistence

توضیح دقیق Event Sourcing و نحوه غلبه بر این محدودیت‌ها

پیاده‌سازی عملی Order aggregate با استفاده از Event Sourcing

بررسی جامع مزایا و معایب Event Sourcing

می‌خواهید:

با یک مثال عملی نشان دهم محدودیت‌های روش‌های سنتی چیست؟

یک نمونه ساده از Order aggregate با Event Sourcing در Node.js پیاده‌سازی کنیم؟

یا درباره یکی از این مفاهیم عمیق‌تر صحبت کنیم؟

با جزئیات در مورد محدودیت‌های روش سنتی persistence صحبت کنیم.

الگو: Event Sourcing

تعریف اصلی: ذخیره‌سازی یک Aggregate به صورت دنباله‌ای از domain event ها که نشان‌دهنده تغییرات وضعیت هستند.

مشکلات روش سنتی Persistence

در روش سنتی، یک نگاشت (mapping) مستقیم بین:

کلاس‌ها به جدول‌های دیتابیس

فیلدهای کلاس‌ها به ستون‌های جدول

نمونه‌های (instances) کلاس‌ها به سطرهای جدول

برای مثال در مورد Order aggregate (که در فصل 5 توضیح داده شده):

Order به جدول ORDER نگاشت می‌شود

OrderLineItems به جدول ORDER_LINE_ITEM نگاشت می‌شود

بگذارید برای درک بهتر این ساختار، یک دیاگرام ترسیم کنم:

می‌خواهید ادامه متن را بخوانیم تا ببینیم دقیقاً چه مشکلاتی در این روش سنتی وجود دارد؟

یا می‌خواهید یک مثال عملی با Node.js نشان دهم که این محدودیت‌ها در عمل چگونه خودشان را نشان می‌دهند؟

بیایید مشکلات روش سنتی persistence را با جزئیات بررسی کنیم:

نحوه ذخیره‌سازی سنتی

در این روش:

یک نمونه Order به صورت سطرهایی در جداول ORDER و ORDER_LINE_ITEM ذخیره می‌شود

این کار معمولاً با استفاده از:

یک ORM framework (مثل JPA)

یا یک framework سطح پایین‌تر (مثل MyBATIS) انجام می‌شود

مشکلات و محدودیت‌های اصلی

با اینکه این روش در اکثر برنامه‌های سازمانی استفاده می‌شود، اما چهار مشکل اصلی دارد:

Object-Relational impedance mismatch (ناهماهنگی بین شیءگرایی و رابطه‌ای)

عدم وجود تاریخچه Aggregate

پیاده‌سازی audit logging خسته‌کننده و مستعد خطا

اتصال سطحی (bolt-on) منطق انتشار رویداد به منطق کسب و کار

تشریح مشکل Object-Relational Impedance Mismatch

این یک مشکل قدیمی و اساسی است که شامل:

ناهماهنگی مفهومی بین ساختار جدولی (schema رابطه‌ای) و ساختار گراف‌مانند یک domain model غنی

پیچیدگی در نگاشت روابط پیچیده domain model به دیتابیس رابطه‌ای

نمونه بحث‌های چالشی

Ted Neward آن را "ویتنام علوم کامپیوتر" نامیده

با اینکه frameworks مثل Hibernate در برخی موارد موفق بوده‌اند (مخصوصاً وقتی schema دیتابیس از مدل شیءگرا مشتق می‌شود)

اما مشکل عمیق‌تر از محدودیت‌های یک ORM framework خاص است

می‌خواهید:

یک مثال عملی از این ناهماهنگی را در Node.js نشان دهم؟

یا به سراغ بررسی سایر مشکلات (مثل عدم وجود تاریخچه یا مشکلات audit logging) برویم؟

بیایید بقیه مشکلات اصلی روش سنتی persistence را بررسی کنیم:

۲. عدم وجود تاریخچه Aggregate

مشکل:

فقط وضعیت فعلی aggregate ذخیره می‌شود

پس از هر به‌روزرسانی، وضعیت قبلی از دست می‌رود

چالش‌های پیاده‌سازی دستی تاریخچه:

نیاز به صرف زمان زیاد

تکرار کد که باید با منطق کسب و کار همگام باشد

ریسک ناهماهنگی بین تاریخچه و وضعیت واقعی

۳. مشکلات Audit Logging

موارد نیاز به Audit:

ردیابی تغییرات انجام شده توسط کاربران

الزامات امنیتی و قانونی

نیازهای کسب و کار (مثل JIRA و Asana که تاریخچه تغییرات task ها را نمایش می‌دهند)

چالش‌ها:

پیاده‌سازی وقت‌گیر

امکان واگرایی کد audit logging از منطق کسب و کار

احتمال بروز باگ در اثر این واگرایی

۴. مشکل Event Publishing

در روش سنتی:

معمولاً پشتیبانی ذاتی از انتشار domain events وجود ندارد

این events (که در فصل ۵ توضیح داده شدند) برای:

همگام‌سازی داده‌ها

ارسال notification ها در معماری میکروسرویس ضروری هستند

محدودیت‌های فعلی:

برخی ORM ها (مثل Hibernate) callback هایی برای تغییرات دارند

اما پشتیبانی خودکار برای انتشار پیام‌ها به عنوان بخشی از تراکنش وجود ندارد

توسعه‌دهندگان باید منطق تولید event را به صورت جداگانه اضافه کنند

ریسک ناهماهنگی با منطق کسب و کار

بیایید یک مثال عملی با Node.js بزنیم که این مشکلات را نشان دهد:

در این کد می‌بینیم که:

حفظ تاریخچه وجود ندارد

Audit logging باید دستی اضافه شود

انتشار event ممکن است فراموش شود

هیچ تضمینی برای همگام‌سازی این موارد با منطق اصلی نیست

راه حل این مشکلات Event Sourcing است که در ادامه به آن می‌پردازیم. می‌خواهید ابتدا درباره Event Sourcing و نحوه حل این مشکلات صحبت کنیم؟

اجازه دهید مفهوم Event Sourcing را با جزئیات بررسی کنیم:

مرور کلی Event Sourcing

تعریف اصلی

Event Sourcing یک تکنیک event-محور است که برای:

پیاده‌سازی منطق کسب و کار

ذخیره‌سازی aggregate ها استفاده می‌شود

نحوه ذخیره‌سازی در Event Sourcing

برخلاف روش سنتی (که در بخش 6.1.1 بررسی شد):

Aggregate به صورت یک سری رویداد در دیتابیس ذخیره می‌شود

هر رویداد نشان‌دهنده یک تغییر وضعیت در aggregate است

منطق کسب و کار aggregate حول تولید و مصرف این رویدادها ساختاردهی می‌شود

بگذارید این تفاوت را با یک دیاگرام نشان دهیم:

مثال با Order Aggregate

در مورد Order aggregate:

روش سنتی: هر Order به صورت یک سطر در جدول ORDER ذخیره می‌شود

Event Sourcing: هر Order به صورت چندین رویداد در جدول EVENTS ذخیره می‌شود، مانند:

Order Created

Order Approved

Order Shipped

و غیره

بیایید یک مثال عملی با Node.js از این رویکرد را ببینیم:

در این پیاده‌سازی مبتنی بر Event Sourcing می‌بینیم که:

هر تغییر وضعیت به صورت یک event ذخیره می‌شود

وضعیت فعلی از پخش مجدد (replay) events ساخته می‌شود

تاریخچه کامل تغییرات به صورت خودکار حفظ می‌شود

امکان audit logging و event publishing به صورت ذاتی وجود دارد

می‌خواهید در مورد جزئیات بیشتری از این پیاده‌سازی صحبت کنیم؟ یا به سراغ ادامه متن برویم؟

بله، اجازه دهید نحوه بازسازی یک aggregate از رویدادها را با جزئیات بررسی کنیم:

مراحل بازسازی Aggregate از Event Store

الگوریتم اصلی

زمانی که برنامه نیاز به بارگذاری یک aggregate دارد، سه مرحله اصلی انجام می‌شود:

بارگیری تمام رویدادهای مربوط به aggregate از جدول EVENTS

ایجاد یک نمونه جدید از aggregate با استفاده از constructor پیش‌فرض

پیمایش رویدادها و اعمال هر کدام با فراخوانی متد apply()

بیایید این مکانیزم را با Node.js پیاده‌سازی کنیم:

نکات مهم در این پیاده‌سازی:

Fold/Reduce عملیات:

همانطور که در متن اشاره شده، این فرآیند معادل یک عملیات fold یا reduce در برنامه‌نویسی تابعی است

وضعیت نهایی از اعمال متوالی رویدادها روی حالت اولیه بدست می‌آید

مزایای این رویکرد:

Immutability: هر تغییر وضعیت به صورت یک رویداد جدید ثبت می‌شود

Traceability: امکان ردیابی دقیق تمام تغییرات

Consistency: تضمین سازگاری بین رویدادها و وضعیت

نکات پیاده‌سازی:

متد applyEvent باید pure باشد (برای همان ورودی همیشه همان خروجی را تولید کند)

رویدادها باید immutable باشند

ترتیب رویدادها اهمیت دارد

می‌خواهید:

درباره جزئیات بیشتری از پیاده‌سازی صحبت کنیم؟

به بررسی مزایا و معایب این رویکرد بپردازیم؟

یا به سراغ ادامه متن برویم؟

دو جنبه مهم از رویدادها در Event Sourcing را بررسی می‌کنیم:

اجازه دهید این بخش مهم را که درباره متدهای Aggregate در Event Sourcing است، با جزئیات بررسی کنیم:

متدهای Aggregate در Event Sourcing

بیایید ابتدا یک دیاگرام برای نشان دادن این جریان بسازیم:

مقایسه روش سنتی و Event Sourcing

بیایید این تفاوت را با کد نشان دهیم:

تفاوت‌های کلیدی

روش سنتی:

متدهای command مستقیماً state را تغییر می‌دهند

validation انجام می‌شود و سپس فیلدها آپدیت می‌شوند

هیچ رویدادی تولید نمی‌شود

روش Event Sourcing:

متدهای command رویداد تولید می‌کنند

validation همچنان انجام می‌شود

بجای تغییر مستقیم state، رویداد تولید می‌شود

رویداد هم در دیتابیس ذخیره می‌شود و هم روی aggregate اعمال می‌شود

مزایای رویکرد Event Sourcing:

تاریخچه کامل تغییرات

امکان بازسازی state در هر نقطه از زمان

جداسازی تولید رویداد از اعمال آن

تضمین انتشار رویداد برای هر تغییر

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی را بررسی کنیم؟

درباره نحوه ذخیره‌سازی این رویدادها صحبت کنیم؟

به سراغ ادامه متن برویم؟

۱. رویدادها نشان‌دهنده تغییرات وضعیت

تفاوت با Domain Events معمولی (فصل ۵):

Domain Events معمولی:

برای اطلاع‌رسانی به subscribers

می‌توانند حداقلی باشند (مثلاً فقط شامل aggregate ID)

یا غنی‌شده باشند (شامل داده‌های مفید برای مصرف‌کننده)

ساختار بر اساس نیاز مصرف‌کنندگان

Events در Event Sourcing:

اجباری برای هر تغییر وضعیت

ساختار بر اساس نیاز خود aggregate

باید تمام داده‌های لازم برای state transition را داشته باشند

بیایید این تفاوت را با یک مثال عملی نشان دهیم:

۲. رابطه Event ها با State Transitions



دو نوع اصلی Event از نظر داده:

Events با داده کم:

مثل OrderShipped

فقط نشان‌دهنده تغییر وضعیت هستند

apply() فقط یک فیلد را تغییر می‌دهد (مثلاً status)

Events با داده زیاد:

مثل OrderCreated

شامل تمام داده‌های لازم برای initialize کردن aggregate

نمی‌توانند minimal باشند چون برای بازسازی state نیاز به تمام اطلاعات است

نکات کلیدی:

هر event باید داده کافی برای انجام state transition را داشته باشد

اگر state فعلی S است و می‌خواهیم به S' برسیم، event E باید طوری باشد که:

S' = S.apply(E)

برخلاف Domain Events معمولی، نمی‌توانیم events را minimal نگه داریم

آیا می‌خواهید:

مثال دیگری از state transition ببینیم؟

درباره چالش‌های این رویکرد صحبت کنیم؟

به سراغ ادامه متن برویم؟

بیایید نحوه بازسازی منطق کسب و کار در Event Sourcing را با جزئیات بررسی کنیم:

بازسازی متدهای Command در Event Sourcing

یک متد command به دو دسته متد تقسیم می‌شود:

متد process() (برای دستورات):

ورودی: Command object (درخواست تغییر)

وظایف:

اعتبارسنجی پارامترها

تعیین تغییرات مورد نیاز

تولید لیست رویدادها

خروجی: لیست رویدادها

نکته: state را تغییر نمی‌دهد

متد apply() (برای رویدادها):

ورودی: Event object

وظیفه: به‌روزرسانی state بر اساس رویداد

نکته: نمی‌تواند شکست بخورد چون رویداد نشان‌دهنده تغییری است که قبلاً تأیید شده

بیایید این مفهوم را با یک مثال عملی در Node.js نشان دهیم:

نکات کلیدی در پیاده‌سازی

جداسازی مسئولیت‌ها:

process(): منطق اعتبارسنجی و تصمیم‌گیری

apply(): منطق به‌روزرسانی state

الگوی Event Sourcing:

Command -> process() -> Events -> apply() -> State Change

مزایای این رویکرد:

جداسازی تمیز validation از state changes

امکان audit و logging بهتر

قابلیت تست بهتر (می‌توان process و apply را جداگانه تست کرد)

امکان replay events برای بازسازی state

نکات پیاده‌سازی:

process() می‌تواند exception پرتاب کند

apply() نباید exception پرتاب کند

هر event type یک apply() method مخصوص به خود دارد

آیا می‌خواهید:

مثال دیگری از کاربرد این الگو ببینیم؟

درباره نحوه تست این کد صحبت کنیم؟

به سراغ ادامه متن برویم؟

بیایید این بخش مهم را که نحوه پیاده‌سازی Order aggregate با Event Sourcing را توضیح می‌دهد، با جزئیات بررسی کنیم:

مراحل کار با Aggregate

ایجاد Aggregate جدید:

ساخت نمونه با constructor پیش‌فرض

فراخوانی process() برای تولید رویدادهای جدید

به‌روزرسانی aggregate با اعمال رویدادها (apply)

ذخیره رویدادهای جدید در event store

به‌روزرسانی Aggregate موجود:

بارگیری رویدادهای aggregate از event store

ساخت نمونه جدید با constructor پیش‌فرض

اعمال رویدادهای بارگیری شده با apply()

فراخوانی process() برای تولید رویدادهای جدید

به‌روزرسانی aggregate با اعمال رویدادهای جدید

ذخیره رویدادهای جدید در event store

بیایید این مفاهیم را با یک پیاده‌سازی کامل‌تر نشان دهیم:

تفاوت‌های کلیدی با نسخه JPA

ساختار فیلدها:

تقریباً مشابه نسخه JPA است

تفاوت اصلی: id aggregate در خود aggregate ذخیره نمی‌شود

متدها:

متدهای factory مثل createOrder() با جفت متدهای process/apply جایگزین شده‌اند

process(): دستور را پردازش و رویداد تولید می‌کند

apply(): رویداد را اعمال و state را به‌روز می‌کند

مزایای این رویکرد:

جداسازی تمیز validation از state changes

تاریخچه کامل تغییرات

قابلیت بازسازی state در هر نقطه از زمان

امکان audit و debugging بهتر

آیا می‌خواهید:

درباره نحوه پیاده‌سازی جنبه خاصی از این کد صحبت کنیم؟

مثالی از نحوه تست این کد ببینیم؟

به سراغ ادامه متن برویم؟

اجازه دهید این بخش را که درباره منطق پیچیده‌تر ویرایش سفارش و مدیریت همزمانی است، با جزئیات بررسی کنیم:

۱. منطق ویرایش سفارش با Event Sourcing

در نسخه قبلی سه متد داشتیم:

reviseOrder()

confirmRevision()

rejectRevision()

در Event Sourcing این متدها با process() و apply() جایگزین شده‌اند. بیایید پیاده‌سازی کنیم:

۲. مدیریت تغییرات همزمان (Concurrent Updates)

در سیستم‌های سنتی از Optimistic Locking با یک فیلد VERSION استفاده می‌شود:

UPDATE AGGREGATE_ROOT_TABLE SET VERSION = VERSION + 1 ... WHERE VERSION =

در Event Sourcing دو روش برای Optimistic Locking داریم:

استفاده از تعداد events به عنوان شماره نسخه

نگهداری یک شماره نسخه مجزا در event store

مزایای این رویکرد:

جلوگیری از overwrite شدن تغییرات همزمان

تضمین سازگاری داده‌ها

امکان تشخیص و مدیریت conflicts

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی optimistic locking را ببینیم؟

نحوه مدیریت conflict‌ها را بررسی کنیم؟

به سراغ ادامه متن برویم؟

بیایید مکانیزم انتشار رویدادها در Event Sourcing را بررسی کنیم:

نقش Event Sourcing در انتشار رویدادها

مفهوم اصلی

Event Sourcing دو کارکرد دارد:

ذخیره‌سازی aggregate ها به صورت رویداد

مکانیزم مطمئن برای انتشار رویدادها

روش‌های انتشار رویداد

دو مکانیزم اصلی (از فصل ۳):

Polling

Transaction log tailing

تفاوت اصلی با سیستم‌های سنتی:

رویدادها به صورت دائمی در جدول EVENTS ذخیره می‌شوند

برخلاف جدول OUTBOX که رویدادها موقتی هستند و بعد حذف می‌شوند

مشکلات Polling در Event Sourcing

بیایید این مشکل را با کد نشان دهیم:

مشکل Polling

سناریوی مشکل‌ساز:

Transaction A: درج رویداد با EVENT_ID = 1010

Transaction B: درج رویداد با EVENT_ID = 1020 و commit سریع‌تر

Event Publisher:

ابتدا رویداد 1020 را می‌بیند

بعداً رویداد 1010 را نادیده می‌گیرد چون ID کمتری دارد

چرا این مشکل رخ می‌دهد:

ترتیب commit تراکنش‌ها می‌تواند با ترتیب تولید event ها متفاوت باشد

استفاده از event_id برای polling می‌تواند منجر به از دست رفتن events شود

راه‌حل‌های ممکن:

استفاده از timestamp به جای event_id

نگهداری set از event‌های پردازش شده

استفاده از transaction log tailing

آیا می‌خواهید:

راه‌حل‌های بهتر برای این مشکل را بررسی کنیم؟

نحوه پیاده‌سازی transaction log tailing را ببینیم؟

به سراغ ادامه متن برویم؟

بیایید راه‌حل‌های مشکل publishing و مفهوم snapshot را بررسی کنیم:

۱. راه حل مشکل Publishing با ستون PUBLISHED

راه حل ساده:

اضافه کردن ستون PUBLISHED به جدول EVENTS

فرآیند انتشار:

یافتن رویدادهای منتشر نشده

انتشار به message broker

علامت‌گذاری رویدادها به عنوان منتشر شده

بیایید این را پیاده‌سازی کنیم:

۲. استفاده از Snapshots برای بهبود کارایی

بیایید مکانیزم snapshot را پیاده‌سازی کنیم:

نکات کلیدی در مورد Snapshot

هدف Snapshot:

بهبود کارایی برای aggregate های با تعداد زیاد رویداد

کاهش زمان بازسازی state

کاهش بار روی event store

مکانیزم کار:

ذخیره دوره‌ای وضعیت aggregate

هنگام بازیابی:

بارگیری آخرین snapshot

بارگیری رویدادهای بعد از snapshot

اعمال رویدادها روی snapshot

روش‌های ذخیره snapshot:

سریالایز کردن JSON برای ساختارهای ساده

استفاده از الگوی Memento برای ساختارهای پیچیده

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی snapshot را ببینیم؟

درباره استراتژی‌های مختلف snapshot گیری صحبت کنیم؟

به سراغ ادامه متن برویم؟

بیایید سه موضوع مهم را بررسی کنیم:

۱. ساختار جداول EVENTS و SNAPSHOTS

۲. پردازش Idempotent پیام‌ها

بیایید دو روش پیاده‌سازی idempotency را نشان دهیم:

۳. مدیریت حالت‌های خاص (No-Op Cases)

مشکلات حالت‌های بدون رویداد:

نبود رکورد برای پردازش پیام

امکان پردازش مجدد نادرست

راه حل‌ها:

استفاده از pseudo-events برای ثبت پردازش پیام

نادیده گرفتن pseudo-events توسط مصرف‌کنندگان

نکات کلیدی پیاده‌سازی:

روش RDBMS:

استفاده از جدول PROCESSED_MESSAGES

ذخیره message ID در تراکنش

یکپارچگی ACID با business logic

روش NoSQL:

ذخیره message ID در خود events

بررسی تکراری بودن با جستجو در events

استفاده از pseudo-events برای حالت‌های no-op

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی pseudo-events را ببینیم؟

نحوه مدیریت خطاها در این سیستم را بررسی کنیم؟

به سراغ ادامه متن برویم؟

بیایید دو بخش مهم درباره تکامل رویدادها و مزایای Event Sourcing را بررسی کنیم:

۱. تکامل رویدادها (Event Evolution)

سطوح Schema در Event Sourcing

سطح Schema:

شامل یک یا چند Aggregate

سطح Aggregate:

تعریف رویدادهای هر Aggregate

سطح Event:

تعریف ساختار رویدادها

بیایید این ساختار و تغییرات آن را با کد نشان دهیم:

۲. مزایای Event Sourcing

انتشار مطمئن Domain Events:

تضمین انتشار رویداد برای هر تغییر وضعیت

ایجاد audit log دقیق

امکان استفاده برای notification، integration و analytics

حفظ تاریخچه Aggregates:

ذخیره کامل تاریخچه تغییرات

امکان بازیابی وضعیت در هر نقطه از زمان

پشتیبانی از temporal queries

حل مشکل O/R Impedance Mismatch:

ذخیره رویدادها به جای aggregate ها

ساختار ساده و قابل سریالایز کردن

استفاده از Memento برای snapshot های پیچیده

Time Machine برای توسعه‌دهندگان:

امکان پیاده‌سازی نیازمندی‌های جدید روی داده‌های گذشته

مثال: بازاریابی برای مشتریانی که در گذشته محصولی را به سبد خرید اضافه و بعد حذف کرده‌اند

آیا می‌خواهید:

مثال عملی از یکی از این مزایا را ببینیم؟

درباره نحوه پیاده‌سازی temporal queries صحبت کنیم؟

به سراغ ادامه متن برویم؟

بیایید معایب و چالش‌های Event Sourcing را با جزئیات بررسی کنیم:

۱. مدل برنامه‌نویسی متفاوت

نیاز به یادگیری مدل جدید

لزوم بازنویسی business logic موجود

بیایید تفاوت مدل برنامه‌نویسی را نشان دهیم:

۲. پیچیدگی در حذف داده‌ها

با توجه به GDPR و مسائل حریم خصوصی، حذف داده‌ها چالش برانگیز است. دو راه حل:

Soft Delete:

تنظیم یک پرچم deleted

انتشار رویداد Deleted

رمزنگاری:

class EncryptedEventStore { constructor() { this.events = new Map(); this.encryptionKeys = new Map(); } async saveEvent(userId, event) { const key = this.encryptionKeys.get(userId); const encryptedEvent = this.encrypt(event, key); this.events.set(event.id, encryptedEvent); } async deleteUser(userId) { // حذف کلید رمزنگاری = حذف موثر داده‌های کاربر this.encryptionKeys.delete(userId); } }

۳. چالش Query زدن روی Event Store

مثال مشکل Query زدن:

۴. پیچیدگی تکامل رویدادها

برای مدیریت تکامل رویدادها نیاز است:

مدیریت نسخه‌های مختلف رویدادها

ارتقاء رویدادها به نسخه جدید هنگام بارگذاری

جداسازی کد ارتقاء از aggregate

آیا می‌خواهید:

درباره راه‌حل‌های دیگر برای هر یک از این چالش‌ها صحبت کنیم؟

نحوه پیاده‌سازی CQRS برای حل مشکل query را بررسی کنیم؟

به سراغ ادامه متن برویم؟

بیایید نحوه پیاده‌سازی Event Store و Event Sourcing Framework را بررسی کنیم:

معماری Event Store

بیایید یک پیاده‌سازی ساده از Event Store را نشان دهیم:

اجزای اصلی Event Store

Event Database:

جدول EVENTS: ذخیره رویدادها

جدول ENTITIES: نگهداری نسخه‌های entity ها

جدول SNAPSHOTS: ذخیره snapshot ها

Event Relay:

خواندن رویدادها از دیتابیس

انتشار به Message Broker

Message Broker:

ارائه API برای subscribe به رویدادها

مدیریت topic های مختلف (مثل Order topic, Customer topic)

گزینه‌های پیاده‌سازی

پیاده‌سازی سفارشی:

استفاده از RDBMS برای ذخیره رویدادها

Polling برای انتشار رویدادها (با مشکلات ذکر شده)

Event Store های آماده:

Event Store (.NET)

Lagom (Lightbend)

Axon (Java)

Eventuate (SaaS یا Local)

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی Event Relay را ببینیم؟

نحوه پیاده‌سازی Snapshot در Event Store را بررسی کنیم؟

به سراغ ادامه متن برویم؟

بیایید ساختار دیتابیس Eventuate Local را با جزئیات بررسی کنیم:

ساختار جداول دیتابیس

عملیات‌های اصلی

find():

بازیابی آخرین snapshot (اگر وجود داشته باشد)

بازیابی events بعد از snapshot یا همه events

بازیابی نسخه فعلی entity

create():

درج سطر در جدول entities

درج events در جدول events

update():

بررسی optimistic locking با UPDATE روی جدول entities

درج events جدید

انجام همه عملیات در یک تراکنش

جداول اصلی

events:

ذخیره رویدادها

شامل ستون triggering_event برای تشخیص رویدادهای تکراری

entities:

نگهداری نسخه فعلی هر entity

پیاده‌سازی optimistic locking

snapshots:

ذخیره snapshot ها

شامل نسخه entity و داده‌های سریالایز شده

آیا می‌خواهید:

نحوه پیاده‌سازی optimistic locking را با جزئیات بیشتر ببینیم؟

مثالی از نحوه استفاده از این دیتابیس در یک سناریوی واقعی ببینیم؟

به سراغ ادامه متن برویم؟

بیایید نحوه مصرف رویدادها و انتقال آنها را در Eventuate بررسی کنیم:

۱. Event Broker با Apache Kafka

بیایید یک پیاده‌سازی ساده از Event Broker نشان دهیم:

۲. Eventuate Client Framework

نکات کلیدی

Event Broker (Apache Kafka):

یک topic برای هر نوع aggregate

استفاده از partition برای scale کردن

aggregateId به عنوان partition key

Event Relay:

انتقال رویدادها از دیتابیس به message broker

استفاده از binlog در MySQL

ذخیره position برای restart

Eventuate Client Framework:

کلاس‌های پایه برای aggregate ها

پشتیبانی از CRUD

API برای subscribe به رویدادها

آیا می‌خواهید:

جزئیات بیشتری از پیاده‌سازی Event Relay را ببینیم؟

نحوه پیاده‌سازی transaction log tailing را بررسی کنیم؟

به سراغ ادامه متن برویم؟

بیایید ساختار کامل Event Sourcing framework را با Command ها و Event ها پیاده‌سازی کنیم:

نکات کلیدی پیاده‌سازی

تعریف Command ها:

هر Command باید interface مخصوص خود را داشته باشد

تمام Command های یک Aggregate از یک interface پایه ارث‌بری می‌کنند

مثال: OrderCommand extends Command

تعریف Event ها:

هر Event باید از interface Event ارث‌بری کند

معمولاً یک interface پایه برای Event های هر Aggregate تعریف می‌شود

مثال: OrderCreatedEvent implements OrderEvent

AggregateRepository:

سه عملیات اصلی:

save(): ایجاد Aggregate جدید

find(): یافتن Aggregate

update(): به‌روزرسانی Aggregate

مدیریت خودکار چرخه حیات Aggregate

چرخه عملیات:

ایجاد Aggregate:

ساخت نمونه با constructor پیش‌فرض

اجرای process() برای Command

اعمال Event ها با apply()

ذخیره Event ها

به‌روزرسانی Aggregate:

بازیابی از event store

اجرای process() برای Command جدید

اعمال Event های جدید

ذخیره Event های جدید

آیا می‌خواهید:

نحوه پیاده‌سازی optimistic locking در repository را ببینیم؟

مثالی از نحوه کار با snapshot ها اضافه کنیم؟

به سراغ ادامه متن برویم؟

بیایید سیستم اشتراک (subscription) و مدیریت Event Handler ها را پیاده‌سازی کنیم:

نکات کلیدی پیاده‌سازی

Decorators برای Event Handling:

@EventSubscriber: مشخص کردن ID برای subscription

@EventHandlerMethod: مشخص کردن متدهای handler

EventHandlerContext:

شامل event و metadata آن

فراهم کردن دسترسی به اطلاعات event

EventSubscriptionManager:

مدیریت ثبت‌نام subscriber ها

پردازش events جدید

پیگیری events پردازش شده

مدیریت خطاها

قابلیت‌های کلیدی:

Durable subscription

تحویل تضمین شده events

پردازش ترتیبی events

مدیریت وضعیت subscription

آیا می‌خواهید:

نحوه پیاده‌سازی retry logic برای event handling را ببینیم؟

مکانیزم ذخیره‌سازی وضعیت subscription را بررسی کنیم؟

به سراغ ادامه متن برویم؟

😄 حق با شماست! بله، بیایید کل ارائه را با تمام جزئیات، مثال‌ها و دیاگرام‌ها آماده کنم.

بخش اول: اسلایدها و توضیحات

بخش دوم: کدها و دیاگرام‌ها

بخش سوم: کدهای عملی

می‌خواهید ادامه بدهم و:

بخش‌های بعدی اسلایدها را با جزئیات بیشتر آماده کنم؟

دیاگرام‌های بیشتری اضافه کنم؟

کدهای نمونه بیشتری برای مثال‌ها اضافه کنم؟

قسمت‌های دیگری که باید پوشش دهیم شامل:

Event Evolution

Snapshots

CQRS Integration

Event Handlers

Best Practices

کدام بخش را اول ببینیم؟
